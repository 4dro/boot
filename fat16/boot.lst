     1                                  CPU 286
     2                                  BITS 16
     3                                  
     4                                  segment	'code'
     5                                  
     6                                  OUR_ADDRESS			equ		7C00h
     7                                  ROOT_LOAD_ADDR		equ		OUR_ADDRESS + 0A00h
     8                                  
     9                                  SEG_ADDRESS_TO_LOAD	equ		2000h
    10                                  
    11                                  var_data_start		equ	-0Ah
    12                                  cached_fat_sector	equ	-6
    13                                  var_reserved		equ	-4
    14                                  
    15 00000000 EB3C                                jmp    short actual_start
    16 00000002 0F                      cluster_mask        db  0Fh
    17                                  ; --------------- Bios Parameters Block ------------------------------------
    18 00000003 6162636465666768        os_name				db 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'
    19 0000000B 0002                    sector_size			dw 200h
    20 0000000D 01                      sec_per_cluster		db 1
    21 0000000E 0100                    reserved_sectors	dw 1
    22 00000010 02                      num_of_fats			db 2
    23 00000011 E000                    root_file_entries	dw 0E0h
    24 00000013 400B                    total_sect_low		dw 0B40h
    25 00000015 F0                      media_type			db 0F0h
    26 00000016 0900                    fat_size			dw 9
    27 00000018 1200                    sec_per_track		dw 12h
    28 0000001A 0200                    num_heads			dw 2
    29 0000001C 00000000                hidden_sectors		dd 0
    30 00000020 00000000                total_sect_large	dd 0
    31 00000024 00                      drive				db 0
    32 00000025 00                      not_used			db 0
    33 00000026 29                      nt_signature		db 29h
    34 00000027 78563412                volume_serial		dd 12345678h
    35 0000002B 202020202020202020-     disk_label			db ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '
    35 00000034 2020               
    36 00000036 4641543132202020        fs_name				db 'F', 'A', 'T', '1', '2', ' ', ' ', ' '
    37                                  
    38                                  ; ------------------------------------------------------------------------
    39                                  
    40                                  actual_start:
    41 0000003E 31C0                                xor     ax, ax
    42                                  
    43 00000040 8ED0                                mov     ss, ax
    44 00000042 BC007C                              mov     sp, OUR_ADDRESS
    45 00000045 89E5                                mov     bp, sp
    46 00000047 8EC0                                mov     es, ax
    47 00000049 8ED8                                mov     ds, ax
    48                                  
    49 0000004B B441                                mov     ah, 41h				; DISK - check ext read	support
    50 0000004D BBAA55                              mov     bx, 55AAh			; signature
    51 00000050 8856[24]                            mov     bp[byte drive], dl	; rely on drive number sent in dl
    52 00000053 CD13                                int     13h
    53 00000055 720A                                jc      short no_ext_bios
    54 00000057 80E101                              and     cl, 1
    55 0000005A 7405                                jz      short no_ext_bios
    56 0000005C C606[C37D]42                        mov     byte [OUR_ADDRESS + bios_read_command + 2], 42h
    57                                  
    58                                  no_ext_bios:
    59 00000061 FC                                  cld
    60                                  ; calculate data start secotor
    61 00000062 31C9                                xor		cx, cx
    62 00000064 8A46[10]                            mov		al, byte bp[byte num_of_fats]
    63 00000067 98                                  cbw
    64 00000068 F766[16]                            mul		word bp[byte fat_size]		; dx:ax - fats size in sectors
    65 0000006B 93                                  xchg	ax, bx
    66 0000006C 87D6                                xchg	dx, si						; si:bx	-> fat size in sectors
    67 0000006E 8B46[0E]                            mov		ax, word bp[byte reserved_sectors]
    68 00000071 99                                  cwd
    69 00000072 0346[1C]                            add		ax, word bp[byte hidden_sectors]
    70 00000075 1356[1E]                            adc		dx, word bp[byte hidden_sectors+2]
    71 00000078 52                                  push	dx		; put into var_reserved
    72 00000079 50                                  push	ax
    73 0000007A 01D8                                add		ax, bx		; + fat size
    74 0000007C 11F2                                adc		dx, si
    75 0000007E 8B76[11]                            mov		si, word bp[byte root_file_entries]
    76 00000081 50                                  push	ax		; init cached_fat_sector with	root start sector (invalid)
    77 00000082 52                                  push	dx		; put root start (dx:ax) into var_datastart
    78 00000083 50                                  push	ax
    79 00000084 60                                  pusha
    80 00000085 96                                  xchg	ax, si
    81 00000086 99                                  cwd
    82 00000087 C1E005                              shl		ax, 5	; multiply by file entry size (32)
    83 0000008A 8B5E[0B]                            mov		bx, word bp[byte sector_size]
    84 0000008D 01D8                                add		ax, bx
    85 0000008F 48                                  dec		ax
    86 00000090 F7F3                                div		bx		; calculate number of sectors needed for root folder (x + sector_size - 1) / sector size
    87 00000092 0146F6                              add     word bp[byte var_data_start], ax
    88 00000095 114EF8                              adc     word bp[byte var_data_start + 2], cx
    89                                  
    90                                  ; calculate total number	of data	clusters
    91 00000098 8B46[13]                            mov     ax, word bp[byte total_sect_low]
    92 0000009B 0B46[20]                            or      ax, word bp[byte total_sect_large]
    93 0000009E 8B56[22]                            mov     dx, word bp[byte total_sect_large + 2]
    94 000000A1 2B46F6                              sub     ax, word bp[byte var_data_start]
    95 000000A4 1B56F8                              sbb     dx, word bp[byte var_data_start + 2]
    96 000000A7 0346[1C]                            add     ax, word bp[byte hidden_sectors]
    97 000000AA 1356[1E]                            adc     dx, word bp[byte hidden_sectors + 2]
    98 000000AD 8A4E[0D]                            mov     cl, byte bp[byte sec_per_cluster]
    99 000000B0 F7F1                                div     cx		; get number of	clusters
   100                                  
   101                                  ; fat type is defined by number of clusters
   102 000000B2 3DF50F                              cmp     ax, 0FF5h
   103 000000B5 7204                                jb      short its_fat12
   104 000000B7 C646[02]FF                          mov     byte bp[byte cluster_mask], 0FFh
   105                                  
   106                                  its_fat12:
   107 000000BB 61                                  popa        ; si - number of root entries
   108                                                          ; dx:ax	- root start sector
   109                                                          ; cx - 0
   110                                  
   111                                  read_root:
   112 000000BC BB0086                              mov     bx, ROOT_LOAD_ADDR
   113 000000BF 89DF                                mov     di, bx
   114 000000C1 E8D700                              call    read_one_sector
   115                                  
   116                                  next_file:
   117 000000C4 380D                                cmp     [di], cl
   118 000000C6 7417                                je      short file_not_found
   119 000000C8 60                                  pusha
   120 000000C9 B10B                                mov     cl, 11
   121 000000CB BE[8C7D]                            mov     si, loader_file_name + OUR_ADDRESS
   122 000000CE F3A6                                repe    cmpsb
   123 000000D0 61                                  popa
   124 000000D1 7410                                je      short loader_found
   125 000000D3 4E                                  dec     si
   126 000000D4 7409                                jz      short file_not_found
   127 000000D6 83C720                              add     di, 20h         ; file entry size in directory
   128 000000D9 39DF                                cmp     di, bx
   129 000000DB 72E7                                jb      short next_file
   130 000000DD EBDD                                jmp     short read_root
   131                                  ; -------------------------------------------------------------------
   132                                  file_not_found:
   133 000000DF B0[82]                              mov     al, missing_file_msg - 100h
   134 000000E1 EB7B                                jmp     short message_exit
   135                                  
   136                                  loader_found:
   137 000000E3 8B451A                              mov     ax, [di + 1Ah]          ; fist cluster of the file
   138 000000E6 BF0020                              mov     di, SEG_ADDRESS_TO_LOAD ; start address (segment) to load file to
   139                                  
   140 000000E9 57                                  push    di      ; save the address to jump to
   141 000000EA 51                                  push    cx      ; later we will return far to SEG_ADDRESS_TO_LOAD:0
   142                                  
   143                                  read_loader_cluster:
   144 000000EB 50                                  push	ax
   145 000000EC 48                                  dec		ax
   146 000000ED 48                                  dec		ax
   147 000000EE 8A4E[0D]                            mov		cl, byte bp[byte sec_per_cluster]
   148 000000F1 F7E1                                mul		cx
   149 000000F3 0346F6                              add		ax, word bp[byte var_data_start]
   150 000000F6 1356F8                              adc		dx, word bp[byte var_data_start + 2]
   151 000000F9 06                                  push	es
   152 000000FA 8EC7                                mov		es, di
   153 000000FC 31DB                                xor		bx, bx
   154 000000FE E89B00                              call	read_sectors
   155 00000101 07                                  pop		es
   156 00000102 C1EB04                              shr		bx, 4
   157 00000105 01DF                                add		di, bx
   158 00000107 58                                  pop		ax          ; ax - cluster
   159 00000108 31D2                                xor		dx, dx
   160                                  
   161                                  ; --------- find next cluster ----------------------------------------------
   162                                              ; calculate FAT record offset on FAT12
   163 0000010A 89C3                                mov     bx, ax
   164 0000010C 807E[02]FF                          cmp     byte bp [byte cluster_mask], 0FFh
   165 00000110 7402                                je      short offset_fat16      ; c flag = 0 for FAT16 since operands are equal
   166 00000112 D1EB                                shr     bx, 1                   ; for FAT12, bx = 0,5 * ax
   167                                  offset_fat16:
   168 00000114 9C                                  pushf               ; c flag indicates on FAT12 cluster is XXX0h - need shift
   169 00000115 01D8                                add     ax, bx		; ax = offset in FAT (either ax * 1.5 or ax * 2)
   170 00000117 11CA                                adc     dx, cx      ; fat16 offset could overflow - 0FFFFh * 2
   171                                  
   172                                  ; ------------- Get next cluster record from FAT ------------------------------
   173                                              ; cx = 0
   174                                              ; dx:ax - byte offset of the cluster in FAT
   175                                  
   176 00000119 BB007E                              mov     bx, OUR_ADDRESS + 200h
   177 0000011C F776[0B]                            div     word bp [byte sector_size]
   178 0000011F 8D7701                              lea     si, [bx + 1]
   179 00000122 01D6                                add     si, dx      ; dx - offset in sector
   180 00000124 99                                  cwd
   181 00000125 0346FC                              add     ax, word bp [byte var_reserved]
   182 00000128 1356FE                              adc     dx, word bp [byte var_reserved + 2]
   183 0000012B 3B46FA                              cmp     ax, bp [byte cached_fat_sector]
   184 0000012E 7423                                jz      short already_read
   185 00000130 8946FA                              mov     bp [byte cached_fat_sector], ax
   186                                  
   187                                  read_one_more:
   188 00000133 E86500                              call    read_one_sector
   189                                  
   190                                  take_fat_record:
   191                                              ; bx -> pointer to the next sector
   192                                              ; si -> pointer to the record + 1
   193                                              ; on FAT12 it is possible that record is split between two sectors
   194 00000136 39DE                                cmp     si, bx
   195 00000138 73F9                                jae     short read_one_more
   196 0000013A 4E                                  dec     si
   197 0000013B AD                                  lodsw               ; read next cluster word
   198                                  
   199 0000013C 9D                                  popf
   200 0000013D 7303                                jnc     short lower_half_byte
   201 0000013F C1E804                              shr     ax, 4       ; on fat12 shift 0XXX0h -> 00XXXh
   202                                  lower_half_byte:
   203 00000142 B3FF                                mov     bl, 0FFh
   204 00000144 8A7E[02]                            mov     bh, bp [byte cluster_mask]  ; bx 0FFFFh on FAT16, 0FFFh on FAT12
   205 00000147 21D8                                and     ax, bx
   206                                              ; ax - next cluster
   207 00000149 B3F8                                mov     bl, 0F8h    ; 0FFF8h or 0FF8h
   208 0000014B 39D8                                cmp     ax, bx      ; is last cluster?
   209 0000014D 729C                                jb      short read_loader_cluster
   210                                  
   211                                  ; ------------- File is loaded, execute it --------------------------------------------
   212 0000014F 8A56[24]                            mov     dl, bp[byte drive]
   213 00000152 CB                                  retf            ; jump to SEG_ADDRESS_TO_LOAD:0 - start of the	loader
   214                                  
   215                                  ; -------------------------------------------------------------------------------
   216                                  
   217                                  already_read:
   218 00000153 035E[0B]                            add     bx, word bp[byte sector_size]
   219 00000156 40                                  inc     ax
   220 00000157 75DD                                jnz     short take_fat_record
   221 00000159 42                                  inc     dx
   222 0000015A EBDA                                jmp     short take_fat_record
   223                                  ; ---------------------------------------------------------------------------
   224                                  
   225                                  print_replace_disk:
   226 0000015C B0[D9]                              mov     al, replace_disk_msg - 100h ; "Replace the disk"
   227                                  
   228                                  message_exit:
   229 0000015E B47D                                mov     ah, 7Dh			; our address + 100h high byte
   230 00000160 96                                  xchg    ax, si
   231                                  
   232                                  print_char:
   233 00000161 AC                                  lodsb
   234 00000162 84C0                                test    al, al
   235 00000164 78F6                                js      short print_replace_disk
   236 00000166 7415                                jz      short wait_exit
   237 00000168 B40E                                mov     ah, 0Eh		; video	- display char and move	cursor;	al-char
   238 0000016A BB0700                              mov     bx, 7		; color	7, page	0
   239 0000016D CD10                                int     10h
   240 0000016F EBF0                                jmp     short print_char
   241                                  ; --------------------------------------------------------------------------------
   242                                  
   243 00000171 0D0A4469736B206572-     disk_error_msg		db 0Dh,	0Ah, 'Disk error'
   243 0000017A 726F72             
   244                                  ; next byte is "cbw" command (98h) which is > 80h
   245                                  ; ---------------------------------------------------------------------------
   246                                  wait_exit:
   247                                              ; al is always 0 here
   248 0000017D 98                                  cbw
   249 0000017E CD16                                int     16h     ; ah = 0, wait for a key press
   250 00000180 CD19                                int     19h     ; reboot the computer
   251                                  
   252                                  ; --------------------------------------------------------------------------
   253 00000182 0D0A4D697373696E67-     missing_file_msg    db 0Dh, 0Ah, 'Missing '
   253 0000018B 20                 
   254                                  
   255 0000018C 4F534C4F4144455220-     loader_file_name    db 'OSLOADER', 3 dup(' ')
   255 00000195 2020               
   256                                  ; next byte is "mov al" command (B0) which is > 80h
   257                                  ; ---------------------------------------------------------------------------
   258                                  
   259                                  disk_error_exit:
   260 00000197 B0[71]                              mov     al, disk_error_msg - 100h
   261 00000199 EBC3                                jmp     short message_exit
   262                                  
   263                                  ; -------------- Read one sector ------------------------------------
   264                                              ; expects cx to be 0
   265                                              ; rest parameters are the same as for read_sectors
   266                                  read_one_sector:
   267                                  
   268 0000019B 41                                  inc     cx
   269                                  ; -------------- Read sectors procedure ------------------------------------
   270                                              ; es:bx	-> buffer
   271                                              ; dx:ax	- address of the sector
   272                                              ; cx - number of sectors to read
   273                                          ; on return:
   274                                              ; cx = 0
   275                                              ; dx:ax - next sector address
   276                                              ; es:bx -> adjusted to point to next address
   277                                              ; other registers are unchanged
   278                                  read_sectors:
   279                                  
   280 0000019C 60                                  pusha           ; save registers
   281                                  
   282                                  ; DAP block end
   283 0000019D 1E                                  push    ds      ; 0
   284 0000019E 1E                                  push    ds
   285 0000019F 52                                  push    dx
   286 000001A0 50                                  push    ax		; 8byte	absolute number	of sector
   287 000001A1 06                                  push    es
   288 000001A2 53                                  push    bx		; address to read to
   289 000001A3 6A01                                push    1		; num sectors
   290 000001A5 6A10                                push    10h		; DAP block size
   291                                  ; DAP block start
   292                                  
   293                                  ; convert abs address to cylinders, heads and tracks for ah=2 bios API
   294 000001A7 91                                  xchg    ax, cx		; save lower address to	cx
   295 000001A8 8B76[18]                            mov     si, word bp[byte sec_per_track]
   296 000001AB 92                                  xchg    ax, dx		; higher -> ax
   297 000001AC 99                                  cwd
   298                                              ; dx:ax = 0:high address
   299 000001AD F7F6                                div     si		    ; higher address / sectors per track
   300                                              ; dx = high address % sec_per_track
   301 000001AF 91                                  xchg    ax, cx		; cx = high address / sec_per_track
   302                                              ; ax = low address
   303 000001B0 F7F6                                div     si		    ; lower	address	/ sectors per track
   304 000001B2 87CA                                xchg    cx, dx		; cx - remainder, dx - higher result
   305                                              ; dx:ax = abs address / sec_per_track
   306                                              ; cx = abs address % sec_per_track
   307 000001B4 F776[1A]                            div     word bp [byte num_heads]
   308                                              ; ax - cylinder, cx - sector, dx - head
   309 000001B7 88D6                                mov     dh, dl		; dh - head (remainder of division)
   310                                  
   311 000001B9 86C4                                xchg    al, ah      ; conver cylinder into bios format
   312 000001BB C0E006                              shl     al, 6       ; bits 0-7 go to CH, 8-9 to bits 6-7 of CL
   313 000001BE 41                                  inc     cx          ; inc sector number because it starts with 1
   314 000001BF 09C1                                or      cx, ax
   315                                  
   316                                  bios_read_command:
   317                                              ; the following command would be replaced to "mov ax, 4201h" if extended
   318                                              ; bios read is supported
   319 000001C1 B80102                              mov     ax, 201h
   320 000001C4 89E6                                mov     si, sp		; pointer to DAP packet	in stack
   321 000001C6 8A56[24]                            mov     dl, bp[byte drive]
   322                                  
   323                                      		; DISK - READ SECTORS INTO MEMORY
   324                                              ; AL = number of sectors to read, CH = track, CL = sector
   325                                              ; DH = head, DL	= drive, ES:BX -> buffer to fill
   326                                              ; Return: CF set on error, AH =	status,	AL = number of sectors read
   327 000001C9 CD13                                int     13h
   328                                  
   329 000001CB 61                                  popa    ; release DAP block from stack (same as add sp, 10h)
   330                                  
   331 000001CC 61                                  popa    ; restore all registers
   332 000001CD 72C8                                jc      short disk_error_exit
   333                                  
   334 000001CF 40                                  inc     ax		; increase read	address
   335 000001D0 7501                                jnz     short no_addr_overflow
   336 000001D2 42                                  inc     dx
   337                                  no_addr_overflow:
   338                                  
   339 000001D3 035E[0B]                            add     bx, word bp [byte sector_size]
   340 000001D6 E2C4                                loop    read_sectors
   341 000001D8 C3                                  retn
   342                                  
   343                                  ; ----------------------------------------------------------------------------
   344                                  
   345 000001D9 0D0A5265706C616365-     replace_disk_msg	db 0Dh,0Ah,'Replace the disk',0
   345 000001E2 20746865206469736B-
   345 000001EB 00                 
   346 000001EC 44524F4F5059313233-             db 'DROOPY12345678901', 0
   346 000001F5 343536373839303100 
   347 000001FE 55AA                            db 55h,	0AAh
